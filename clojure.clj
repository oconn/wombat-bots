(def sample-arena
  [[{:contents {:type "fog"}}
    {:contents {:type "fog"}}
    {:contents {:type "fog"}}
    {:contents {:type "fog"}}
    {:contents {:type "fog"}}
    {:contents {:type "fog"}}
    {:contents {:type "fog"}}]
   [{:contents
     {:type "wood-barrier",
      :hp 20,
      :uuid "174cb9d2-5634-48fb-9e9d-1a256cc3ad04",
      :deterioration-level "low"},
     :meta []}
    {:contents
     {:type "wood-barrier",
      :hp 20,
      :uuid "ba4cacd8-438f-41ab-8978-948281157691",
      :deterioration-level "low"},
     :meta []}
    {:contents
     {:type "wood-barrier",
      :hp 20,
      :uuid "11fefbb1-cd48-4bf9-9b11-0df1ed51b1c8",
      :deterioration-level "low"},
     :meta []}
    {:contents
     {:type "wood-barrier",
      :hp 20,
      :uuid "2dd14184-1bdf-421d-9bdf-3914df66dbe6",
      :deterioration-level "low"},
     :meta []}
    {:contents
     {:type "wood-barrier",
      :hp 20,
      :uuid "70a4ee76-061c-4c47-8a0a-58b2cd4ef25c",
      :deterioration-level "low"},
     :meta []}
    {:contents
     {:type "wood-barrier",
      :hp 20,
      :uuid "111e951e-9950-43eb-9981-5a1a9b44c1d4",
      :deterioration-level "low"},
     :meta []}
    {:contents
     {:type "wood-barrier",
      :hp 20,
      :uuid "4fb7a428-e3d8-4b81-9e49-9f084441b953",
      :deterioration-level "low"},
     :meta []}]
   [{:contents
     {:type "food", :uuid "d13b18eb-6c27-44a1-b88b-7e9b4d0b022a"},
     :meta []}
    {:contents
     {:type "open", :uuid "32556f3e-4c66-4645-9b20-71932faaf29f"},
     :meta []}
    {:contents
     {:type "open", :uuid "d1b70537-8614-4cc2-881d-cded36ecae17"},
     :meta []}
    {:contents
     {:type "food", :uuid "a3a8a883-6f0a-4b4e-980d-8fbf5355029e"},
     :meta []}
    {:contents
     {:type "open", :uuid "ad517c6c-edc4-4a28-903c-d81818b4572b"},
     :meta []}
    {:contents
     {:type "open", :uuid "124b471e-722c-471c-9771-8a35cf68be28"},
     :meta []}
    {:contents
     {:type "open", :uuid "b8ec04d4-7855-44fa-b600-eeba75b9f3be"},
     :meta []}]
   [{:contents
     {:type "open", :uuid "c8d35c13-e34a-4aa5-b8b1-62f90a4cf704"},
     :meta []}
    {:contents
     {:type "open", :uuid "32556f3e-4c66-4645-9b20-71932faaf29f"},
     :meta []}
    {:contents
     {:type "open", :uuid "d1b70537-8614-4cc2-881d-cded36ecae17"},
     :meta []}
    {:contents
     {:type "wombat",
      :uuid "3f7f33fb-d16d-4b0b-a948-657bf864e0fa",
      :color "gray",
      :hp 100,
      :orientation "e",
      :deterioration-level "low"},
     :meta []}
    {:contents
     {:type "open", :uuid "ad517c6c-edc4-4a28-903c-d81818b4572b"},
     :meta []}
    {:contents
     {:type "poison", :uuid "e5e2937a-badd-440c-bee3-c9ef65818d97"},
     :meta []}
    {:contents
     {:type "open", :uuid "b8ec04d4-7855-44fa-b600-eeba75b9f3be"},
     :meta []}]
   [{:contents
     {:type "open", :uuid "c8d35c13-e34a-4aa5-b8b1-62f90a4cf704"},
     :meta []}
    {:contents
     {:type "open", :uuid "32556f3e-4c66-4645-9b20-71932faaf29f"},
     :meta []}
    {:contents
     {:type "open", :uuid "d1b70537-8614-4cc2-881d-cded36ecae17"},
     :meta []}
    {:contents
     {:type "open", :uuid "19817042-e591-488a-ae91-8b5c993d87ec"},
     :meta []}
    {:contents
     {:type "poison", :uuid "bffe627e-f7c3-4ea2-9762-fa5ac14a82ad"},
     :meta []}
    {:contents
     {:type "open", :uuid "124b471e-722c-471c-9771-8a35cf68be28"},
     :meta []}
    {:contents
     {:type "open", :uuid "b8ec04d4-7855-44fa-b600-eeba75b9f3be"},
     :meta []}]
   [{:contents
     {:type "open", :uuid "c8d35c13-e34a-4aa5-b8b1-62f90a4cf704"},
     :meta []}
    {:contents
     {:type "open", :uuid "32556f3e-4c66-4645-9b20-71932faaf29f"},
     :meta []}
    {:contents
     {:type "open", :uuid "d1b70537-8614-4cc2-881d-cded36ecae17"},
     :meta []}
    {:contents
     {:type "open", :uuid "19817042-e591-488a-ae91-8b5c993d87ec"},
     :meta []}
    {:contents
     {:type "open", :uuid "ad517c6c-edc4-4a28-903c-d81818b4572b"},
     :meta []}
    {:contents
     {:type "open", :uuid "124b471e-722c-471c-9771-8a35cf68be28"},
     :meta []}
    {:contents
     {:type "open", :uuid "b8ec04d4-7855-44fa-b600-eeba75b9f3be"},
     :meta []}]
   [{:contents
     {:type "open", :uuid "c8d35c13-e34a-4aa5-b8b1-62f90a4cf704"},
     :meta []}
    {:contents
     {:type "open", :uuid "32556f3e-4c66-4645-9b20-71932faaf29f"},
     :meta []}
    {:contents
     {:type "open", :uuid "d1b70537-8614-4cc2-881d-cded36ecae17"},
     :meta []}
    {:contents
     {:type "open", :uuid "19817042-e591-488a-ae91-8b5c993d87ec"},
     :meta []}
    {:contents
     {:type "open", :uuid "ad517c6c-edc4-4a28-903c-d81818b4572b"},
     :meta []}
    {:contents
     {:type "open", :uuid "124b471e-722c-471c-9771-8a35cf68be28"},
     :meta []}
    {:contents
     {:type "open", :uuid "b8ec04d4-7855-44fa-b600-eeba75b9f3be"},
     :meta []}]])


(fn [state time-left]
  ;; TODO Wrap code below into this fn
)

(def ^:private
  orientations
  [:n :s :e :w])

(defn- get-arena-dimensions
  "returns the dimensions of a given arena (NOTE: NOT 0 indexed)"
  {:added "1.0"
   :defined-in "wombats.arena.utils"}
  [arena]
  (let [x ((comp count first) arena)
        y (count arena)]
    [x y]))

(defn- get-arena-dimensions-zero-based
  "returns the dimensions of a given arena"
  {:added "1.0"}
  [arena]
  (map dec (get-arena-dimensions arena)))

(defn- get-in-arena
  "pulls the cell contents out of an arena at given coords"
  {:added "1.0"}
  [[x y] arena]
  (get-in arena [y x]))

(defn- modify-orientation
  "Return a new orientation based off a provided orientation and the direction
  you want to turn"
  {:added "1.0"
   :defined "wombats.game.utils"}
  [current-orientation modifier]
  (let [current-idx (.indexOf orientations current-orientation)]
    (if (not= current-idx -1)
      (condp = modifier
        :right (get orientations (mod (inc current-idx) 4))
        :left (get orientations (mod (dec current-idx) 4))
        :about-face (get orientations (mod (+ 2 current-idx) 4))
        current-orientation)
      current-orientation)))

(defn- get-move-coords
  "Gets the updated coords for moving.

  :Note wrapping not assumed."
  {:added "1.0"}
  [[x y] orientation]
  (case orientation
    :n [x (dec y)]
    :e [(inc x) y]
    :s [x (inc y)]
    :w [(dec x) y]))

(defn- get-move-frontier
  "Returns the coords from the move command"
  {:added "1.0"}
  ([coords orientation dimensions]
   (get-move-frontier coords orientation dimensions false))
  ([[x y] orientation [max-x max-y] wrap?]
   (let [new-coords (get-move-coords [x y] orientation)
         [new-x new-y] new-coords]
     (if wrap?
       (case orientation
         (:n :s) [new-x (mod new-y max-y)]
         (:e :w) [(mod new-x max-x) new-y])
       (case orientation
         :n (if (< new-y 0) nil new-coords)
         :w (if (< new-x 0) nil new-coords)
         :e (if (> new-x max-x) nil new-coords)
         :s (if (> new-y max-y) nil new-coords))))))

(defn- calculate-frontier
  "Caclulates the new frontier set based off of the provided frontier."
  {:added "1.0"}
  ([frontier arena-dimensions]
   (calculate-frontier frontier arena-dimensions false))
  ([{:keys [orientation coords weight cmd-sequence]} arena-dimensions wrap?]
   (let [frontier-orientations
         (map (fn [next-direction]
                {:orientation (modify-orientation orientation next-direction)
                  :coords coords
                  :weight (inc weight)
                  :cmd-sequence (conj cmd-sequence {:action :turn
                                                    :metadata {:direction next-direction}})})
              (if (= weight 0)
                [:right :left :about-face]
                [:right :left]))

         frontier-move
         {:orientation orientation
          :coords (get-move-frontier coords orientation arena-dimensions wrap?)
          :weight (inc weight)
          :cmd-sequence (conj cmd-sequence {:action :move})}]
     (conj frontier-orientations frontier-move))))

(defn- can-safely-occupy-space?
  "Predicate used to determine what cells can pass as frontiers"
  {:added "1.0"}
  [cell]
  (not (contains? #{"wood-barrier" "steel-barrier" "fog"}
                  (get-in cell [:contents :type]))))

(defn- filter-frontier
  "Filters all the possible frontiers, returning only explore-able frontiers"
  {:added "1.0"}
  [frontier arena explored]
  (filter (fn [{coords :coords}]
            (if (nil? coords)
              false
              (let [cell (get-in-arena coords arena)
                    uuid (get-in cell [:contents :uuid])]
                (and (nil? (get explored uuid))
                     (can-safely-occupy-space? cell))))) frontier))

(defn- add-to-sorted-arena
  "Adds a frontier node to the sorted arena"
  {:added "1.0"}
  [sorted-arena
   {{type :type
     uuid :uuid} :contents}
   {weight :weight
    coords :coords
    cmd-sequence :cmd-sequence}]
  (let [formatted-frontier {:weight weight
                            :uuid uuid
                            :coords coords
                            :cmd-sequence cmd-sequence}]
    (update-in sorted-arena
               [weight (keyword type)]
               (fn [coll]
                 (if (not (nil? coll))
                   (conj coll formatted-frontier)
                   [formatted-frontier])))))

(defn- to-global-coords
  "Converts local coordinates passed by the partially occluded arena
  to their corresponding global coordinates"
  {:added "1.0"}
  [{[origin-x origin-y] :local-coords
    [global-x global-y] :global-coords
    [dim-x dim-y] :global-dimensions}]
  (fn [[target-x target-y]]
    (let [delta-x (- target-x origin-x)
          delta-y (- target-y origin-y)
          new-x (mod (+ global-x delta-x) dim-y)
          new-y (mod (+ global-y delta-y) dim-x)]
      [new-x new-y])))

(defn sort-arena-by-distance-then-type
  "sorts an arena by distance then type"
  {:added "1.0"}
  [{:keys [arena local-coords] :as enriched-state}]
  (let [arena-dimensions (get-arena-dimensions-zero-based arena)
        update-global-coords-fn (to-global-coords enriched-state)
        {{orientation-str :orientation
          uuid :uuid} :contents} (get-in-arena local-coords arena)
        orientation (keyword orientation-str)]
    (loop [frontier [{:coords local-coords
                      :orientation orientation
                      :uuid uuid
                      :weight 0
                      :cmd-sequence []}]
           explored {}
           sorted-arena []]
      (if (empty? frontier)
        (assoc enriched-state :sorted-arena sorted-arena)

        (let [frontier-node (first frontier)
              cell (get-in-arena (:coords frontier-node) arena)
              next-frontier (calculate-frontier frontier-node arena-dimensions)
              filtered-frontier (filter-frontier next-frontier arena explored)]
          (recur (vec (concat (rest frontier) filtered-frontier))
                 (merge explored {(get-in cell [:contents :uuid]) true})
                 (add-to-sorted-arena sorted-arena
                                      cell
                                      (update frontier-node
                                              :coords
                                              update-global-coords-fn))))))))

(defn- remove-self
  [uuid]
  (fn [{:keys [wombat] :as weight-map}]
    (if wombat
      (let [filtered-list (vec (filter #(not= uuid (:uuid %)) wombat))]
        (if (empty? filtered-list)
          (dissoc weight-map :wombat)
          (assoc weight-map :wombat filtered-list)))
      weight-map)))

(defn- remove-self-from-sorted-arena
  "removes current user from the sorted arena"
  {:added "1.0"}
  [{:keys [local-coords arena my-uuid] :as enriched-state}]
  (update-in
   enriched-state
   [:sorted-arena]
   (fn [sorted-arena]
     (-> sorted-arena
         (update 0 (remove-self my-uuid))
         (update 1 (remove-self my-uuid))))))

(defn- track-able-cell?
  [{{type :type} :contents}]
  (not (contains? #{"fog"} type)))

(defn- update-global-view
  "updates what your bot has seen historically"
  {:added "1.0"}
  [{:keys [global-arena arena my-uuid] :as enriched-state}]
  (let [update-global-coords-fn (to-global-coords enriched-state)
        current-global-arena (if global-arena
                               global-arena
                               (vec (repeat 10 (vec (repeat 10 nil)))))]

    (assoc enriched-state :global-arena
           (:y-global-arena
            (reduce
             (fn [{:keys [y-idx y-global-arena] :as acc} row]
               {:y-idx (inc y-idx)
                :y-global-arena
                (:x-global-arena
                 (reduce
                  (fn [{:keys [x-idx x-global-arena]} cell]
                    {:x-idx (inc x-idx)
                     :x-global-arena (if (track-able-cell? cell)
                                       (assoc-in x-global-arena
                                                 (update-global-coords-fn
                                                  (reverse [x-idx y-idx]))
                                                 cell)
                                       x-global-arena)})
                  {:x-idx 0
                   :x-global-arena y-global-arena} row))})
             {:y-idx 0
              :y-global-arena current-global-arena} arena)))))

(defn- add-my-uuid
  [{:keys [local-coords arena] :as enriched-state}]
  (let [self (get-in-arena local-coords arena)]
    (assoc enriched-state :my-uuid (get-in self [:contents :uuid]))))

(defn- add-closest-food
  [{:keys [sorted-arena] :as enriched-state}]
  (assoc enriched-state
         :closest-food
         (reduce (fn [food weight-map]
                   (if food
                     food
                     (if (:food weight-map)
                       (first (:food weight-map))
                       nil)))
                 nil
                 sorted-arena)))

(defn- choose-action
  [{:keys [closest-food action-taken] :as enriched-state}]
  (let [action-seq (or closest-food [{}])
        action (first action-seq)
        remaining-action-seq (vec (rest action-seq))]
    (merge {:action action
            :remaining-action-seq remaining-action-seq})))

(defn- format-response
  [{:keys [closest-food] :as enriched-state}]
  {:action (if closest-food
             (first closest-food)
             {})
   :state enriched-state}

  ;; TODO
  enriched-state)

(defn enrich-state
  "Adds additional information to the given state used to improve
     the decision-making process"
  {:added "1.0"}
  [{:keys [arena local-coords] :as state}]
  (-> state
      (add-my-uuid)
      (sort-arena-by-distance-then-type)
      (remove-self-from-sorted-arena)
      (add-closest-food)
      (update-global-view)
      (choose-action)
      (format-response)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Evaluate each expresion with C-x C-e and then evaluate the
;; following to test algorithms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- benchmark
  "Benchmarks fn for testing algorithms"
  {:added "1.0"}
  [my-function]
  (time (my-function))
  :done)

(def ^:private sample-state
  {:local-coords [3 3]
   :global-coords [2 1]
   :global-dimensions [11 11]
   :arena sample-arena
   :saved-state {}})

;; Test the sort algorithm
(clojure.pprint/pprint
 (sort-arena-by-distance-then-type sample-state))
(benchmark #(sort-arena-by-distance-then-type sample-state))

;; Test state enrichment
(clojure.pprint/pprint
 (enrich-state sample-state))
(benchmark #(enrich-state sample-state))
